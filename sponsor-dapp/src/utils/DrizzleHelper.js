export default class DrizzleHelper {
  constructor(drizzle) {
    this.drizzle = drizzle;
  }

  // addContract adds the specified address to drizzle.
  addContract(address, abi) {
    const drizzle = this.drizzle;

    return new Promise((resolve, reject) => {
      const contract = drizzle.contracts[address];
      if (contract) {
        resolve(contract);
      }

      drizzle.addContract({
        contractName: address,
        web3Contract: new drizzle.web3.eth.Contract(abi, address)
      });

      const unsubscribe = drizzle.store.subscribe(() => {
        const contract = drizzle.contracts[address];
        if (!contract) {
          return;
        }

        unsubscribe();
        resolve(contract);
      });
    });
  }

  // cacheCall requests data from the provider and returns a promise.
  // The promise resolves an object { address, methodName, key, result }
  // or rejects if the contract specified in `address` has not been added to drizzle.
  cacheCall(address, methodName, args) {
    const drizzle = this.drizzle;
    return new Promise((resolve, reject) => {
      const contract = drizzle.contracts[address];
      if (!contract) {
        reject(`contract ${address} does not exist`);
      }

      const key = contract.methods[methodName].cacheCall(...args);
      // TODO: Check the contract state here and immediately resolve if data exists and is fresh.

      const unsubscribe = drizzle.store.subscribe(() => {
        const contractState = drizzle.store.getState().contracts[address];
        if (!contractState) {
          return;
        }

        const result = contractState[methodName][key];
        if (!result) {
          return;
        }

        unsubscribe();
        resolve({ address, methodName, key, result: result.value });
      });
    });
  }

  // cacheCallAll accepts an array of objects { address, methodName, args }.
  // Returns a promsie with an array of objects { address, methodName, key, result }.
  // Rejects if any contract in `callArgs` has not been added to drizzle.
  cacheCallAll(callArgs) {
    const allPromises = callArgs.map(({ address, methodName, args }) => {
      return this.cacheCall(address, methodName, args);
    });

    return Promise.all(allPromises);
  }

  // _generateArgsHash returns the key generated by Drizzle to store the
  // return value of the function call. Underneath the hood, Drizzle
  // converts arguments into a string and generates the sha3 output.
  // source: https://github.com/trufflesuite/drizzle/blob/fdd53ee84c28a85acbb541cbc359b0b967aa5624/src/DrizzleContract.js#L59
  _generateArgsHash(address, args) {
    if (!args.length) {
      return "0x0";
    }

    const contract = this.drizzle.contracts[address];
    return contract.generateArgsHash(args);
  }

  _getContract(address) {
    return this.drizzle.store.getState().contracts[address];
  }

  // hasCache returns true if a cached value exists for the method/arguments pair.
  hasCache(address, methodName, args) {
    const contract = this._getContract(address);
    if (!contract) {
      return false;
    }

    const key = this._generateArgsHash(address, args);
    return contract[methodName][key] !== undefined;
  }

  // cacheHasError returns true if a cached value exists with an error (e.g. revert/require)
  cacheHasError(address, methodName, args) {
    const contract = this._getContract(address);
    if (!contract) {
      return false;
    }

    const key = this._generateArgsHash(address, args);
    return contract[methodName][key] !== undefined && contract[methodName][key].error !== undefined;
  }

  // getCache synchronously returns the cached value for the method/argument pair.
  // Use `hasCache` to check for the existence of a cached value.
  // The returned value may be stale. Call `cacheCall` to asynchronously fetch a fresh value.
  getCache(address, methodName, args) {
    const key = this._generateArgsHash(address, args);
    return this._getContract(address)[methodName][key].value;
  }
}
